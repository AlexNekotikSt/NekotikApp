# Мета

Розробити модель "**Проекту**", яка буде агрегувати віджети та забезпечувати зручний механізм перебору елементів за допомогою патерну "Ітератор". Це дозволить абстрагувати логіку доступу до елементів колекції, забезпечити гнучкість у роботі з різними структурами даних та спростити інтеграцію з іншими компонентами системи.

## Основні завдання

### 1. Агрегація віджетів
- Модель "Проекту" повинна зберігати віджети, розподілені за колонками (наприклад, `Column1`, `Column2`, `Column3`).
- Забезпечити методи для додавання, видалення та оновлення віджетів у конкретних колонках.

### 2. Реалізація патерну "Ітератор"
- Створити інтерфейс `IIterator<T>` для визначення базових операцій ітератора:
  - `T Current { get; }` — отримання поточного елемента.
  - `bool MoveNext()` — перехід до наступного елемента.
  - `void Reset()` — скидання ітератора до початкового стану.
- Створити інтерфейс `IIteratorAggregate<T>` для визначення колекції, яка може надавати ітератор:
  - `IIterator<T> GetIterator()`.

### 3. Ключові можливості ітератора
- Ітератор повинен забезпечувати послідовний перебір елементів у всіх колонках проекту.
- Логіка ітерації повинна бути інкапсульована в окремому класі, щоб не ускладнювати модель "Проекту".
- Забезпечити підтримку скидання ітератора (`Reset`) для повторного перебору.

### 4. Гнучкість і розширюваність
- Можливість додавання нових колонок або зміни структури даних без порушення роботи ітератора.
- Забезпечити можливість використання ітератора в циклах `foreach` через реалізацію `IEnumerable<T>`.

### 5. Інтеграція з іншими компонентами
- Забезпечити сумісність з існуючими класами віджетів (`WidgetBase` та його похідними).
- Інтегрувати модель "Проекту" з іншими патернами, такими як "Команда" (Command) та "Стратегія" (Strategy).



## Ключові моменти, які вирішує патерн "Ітератор"

### 1. Інкапсуляція логіки перебору
- Логіка доступу до елементів колекції прихована всередині ітератора, що спрощує код клієнта.

### 2. Уніфікований доступ до елементів
- Незалежно від структури даних (список, масив, дерево тощо), клієнт отримує єдиний інтерфейс для перебору.

### 3. Розширюваність
- Легко додавати нові способи перебору (наприклад, фільтровані або зворотні ітерації) без зміни існуючого коду.

### 4. Сумісність із `foreach`
- Реалізація інтерфейсу `IEnumerable<T>` дозволяє використовувати ітератор у стандартних конструкціях C#.



## Архітектура рішення

### 1. Інтерфейси
- `IIterator<T>` — визначає базові операції ітератора.
- `IIteratorAggregate<T>` — визначає колекцію, яка може надавати ітератор.

### 2. Модель "Проекту"
- Зберігає віджети у трьох колонках: `Column1`, `Column2`, `Column3`.
- Надає методи для додавання, видалення та оновлення віджетів.
- Реалізує інтерфейс `IIteratorAggregate<WidgetBase>`.

### 3. Ітератор "Проекту"
- Реалізує інтерфейс `IIterator<WidgetBase>`.
- Забезпечує послідовний перебір елементів у всіх колонках.
